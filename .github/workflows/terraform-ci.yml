# -----------------------------------------------------------------------
# CI: Terraform fmt, lint, validate, plan on every PR.
# Apply runs only on merge to main.
#
# PR blocking: configure these as required status checks in:
#   GitHub → Settings → Branches → main → Require status checks:
#     - Format check
#     - tflint
#     - Validate (dev)
#     - Plan (dev)
#
# Secrets required (Settings → Secrets and variables → Actions):
#   GCP_WORKLOAD_IDENTITY_PROVIDER  — WIF provider resource name
#   GCP_SERVICE_ACCOUNT             — SA email that CI impersonates
#   TF_STATE_BUCKET_DEV             — GCS bucket name for dev state
# -----------------------------------------------------------------------
name: Terraform CI

on:
  pull_request:
    branches: [main]
    paths:
      - "environments/**"
      - "modules/**"
      - ".github/workflows/terraform-ci.yml"
  push:
    branches: [main]
    paths:
      - "environments/**"
      - "modules/**"

permissions:
  contents: read
  id-token: write        # Workload Identity Federation
  pull-requests: write   # Post/update PR comments

env:
  TF_VERSION: "1.7.5"
  TFLINT_VERSION: "0.50.3"
  TF_INPUT: "false"
  TF_CLI_ARGS: "-no-color"

jobs:
  # -----------------------------------------------------------------------
  # Format: terraform fmt --check
  # No credentials needed — purely local check.
  # -----------------------------------------------------------------------
  fmt:
    name: Format check
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Check formatting
        run: terraform fmt -recursive -check

  # -----------------------------------------------------------------------
  # Lint: tflint with google ruleset
  # No credentials needed.
  # -----------------------------------------------------------------------
  lint:
    name: tflint
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: terraform-linters/setup-tflint@v4
        with:
          tflint_version: v${{ env.TFLINT_VERSION }}

      - name: Init tflint plugins
        run: tflint --init
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Lint modules
        run: tflint --recursive --chdir=modules

      - name: Lint environments
        run: tflint --recursive --chdir=environments

  # -----------------------------------------------------------------------
  # Validate: terraform validate
  # Uses -backend=false so no GCS credentials needed.
  # -----------------------------------------------------------------------
  validate:
    name: Validate (dev)
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: terraform init (local backend)
        working-directory: environments/dev
        run: terraform init -backend=false

      - name: terraform validate
        working-directory: environments/dev
        run: terraform validate

  # -----------------------------------------------------------------------
  # Plan: init with real GCS backend + plan, post output to PR.
  # Runs only on pull_request. Blocked by fmt, lint, validate.
  # Updates the same PR comment on each push (no comment spam).
  # -----------------------------------------------------------------------
  plan:
    name: Plan (dev)
    runs-on: ubuntu-latest
    needs: [fmt, lint, validate]
    if: github.event_name == 'pull_request'
    steps:
      - uses: actions/checkout@v4

      - uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: true

      # Install yq to read state prefix from values.yml
      - name: Install yq
        run: |
          sudo wget -qO /usr/local/bin/yq \
            https://github.com/mikefarah/yq/releases/download/v4.43.1/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq

      # Keyless auth — OIDC token exchanged for short-lived GCP access token
      - name: Authenticate to GCP
        id: auth
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}

      - name: terraform init
        working-directory: environments/dev
        run: |
          terraform init \
            -backend-config="bucket=${{ secrets.TF_STATE_BUCKET_DEV }}" \
            -backend-config="prefix=$(yq '.state.prefix' values.yml)"

      - name: terraform plan
        id: plan
        working-directory: environments/dev
        # exit code: 0 = no changes, 1 = error, 2 = changes present
        # continue-on-error so we can post the output before failing
        run: terraform plan -detailed-exitcode -out=tfplan
        continue-on-error: true

      # Find an existing plan comment on this PR and update it,
      # or create a new one if none exists. Avoids comment spam.
      - name: Update PR comment
        uses: actions/github-script@v7
        env:
          PLAN_OUTPUT: ${{ steps.plan.outputs.stdout }}
          PLAN_EXIT:   ${{ steps.plan.outputs.exitcode }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const status = process.env.PLAN_EXIT === '0' ? '✅ No changes'
                         : process.env.PLAN_EXIT === '2' ? '⚠️ Changes pending'
                         : '❌ Error';

            const body = [
              `### Terraform Plan — \`dev\` ${status}`,
              `> Triggered by @${{ github.actor }} on \`${{ github.event_name }}\` · ${{ github.sha }}`,
              '',
              '<details><summary>Show plan</summary>',
              '',
              '```hcl',
              process.env.PLAN_OUTPUT,
              '```',
              '</details>',
            ].join('\n');

            const marker = '### Terraform Plan — `dev`';
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo:  context.repo.repo,
              issue_number: context.issue.number,
            });

            const existing = comments.find(c =>
              c.user.type === 'Bot' && c.body.includes(marker)
            );

            if (existing) {
              await github.rest.issues.updateComment({
                owner:      context.repo.owner,
                repo:       context.repo.repo,
                comment_id: existing.id,
                body,
              });
            } else {
              await github.rest.issues.createComment({
                owner:        context.repo.owner,
                repo:         context.repo.repo,
                issue_number: context.issue.number,
                body,
              });
            }

      # Fail the job if plan errored (exit code 1)
      - name: Assert plan succeeded
        if: steps.plan.outputs.exitcode == '1'
        run: exit 1

  # -----------------------------------------------------------------------
  # Apply: runs on merge to main only, after all checks pass.
  # Blocked by fmt, lint, validate (plan only runs on PRs).
  # -----------------------------------------------------------------------
  apply-dev:
    name: Apply (dev)
    runs-on: ubuntu-latest
    needs: [fmt, lint, validate]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    environment:
      name: dev
      url: https://console.cloud.google.com/kubernetes

    steps:
      - uses: actions/checkout@v4

      - uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Install yq
        run: |
          sudo wget -qO /usr/local/bin/yq \
            https://github.com/mikefarah/yq/releases/download/v4.43.1/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq

      - name: Authenticate to GCP
        id: auth
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}

      - name: terraform init
        working-directory: environments/dev
        run: |
          terraform init \
            -backend-config="bucket=${{ secrets.TF_STATE_BUCKET_DEV }}" \
            -backend-config="prefix=$(yq '.state.prefix' values.yml)"

      - name: terraform apply
        working-directory: environments/dev
        run: terraform apply -auto-approve
